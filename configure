#!/usr/bin/env ruby

################################################################################
# This file is part of Butane.
#
# Copyright (c) Michael Williams <devbug@bitbyte.ca>
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer. Redistributions in binary
# form must reproduce the above copyright notice, this list of conditions and
# the following disclaimer in the documentation and/or other materials provided
# with the distribution. Neither the name of the nor the names of its
# contributors may be used to endorse or promote products derived from this
# software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
################################################################################

require 'optparse'
require 'ostruct'
require 'rbconfig'

class SwitchesAndOptions
  def self.switch(name)
    (ENV['CONFIG_' + name.upcase] == 'yes')
  end

  private_class_method :switch

  def self.option(name)
    if ENV.include? 'CONFIG_' + name.upcase
      ENV['CONFIG_' + name.upcase]
    end
  end

  private_class_method :option

  def self.is_known_configuration?(configuration)
    case configuration.downcase
    when "debug"
      true
    when "development"
      true
    when "release"
      true
    else
      false
    end
  end

  private_class_method :is_known_configuration?

  def self.architecture
    host_cpu = RbConfig::CONFIG['host_cpu'].downcase
    if host_cpu =~ /i[0-6]86/i
      "x86"
    else
      abort("Unknown 'host_cpu' #{host_cpu}!")
    end
  end

  private_class_method :architecture

  def self.is_known_architecture?(architecture)
    case architecture.downcase
    when "x86"
      true
    when "x86-64"
      true
    when "arm"
      true
    else
      false
    end
  end

  private_class_method :is_known_architecture?

  def self.is_supported_architecture?(architecture)
    case architecture.downcase
    when "x86"
      true
    when "x86-64"
      true
    when "arm"
      false
    else
      false
    end
  end

  private_class_method :is_supported_architecture?

  def self.toolchain
    host_os = RbConfig::CONFIG['host_os'].downcase
    if host_os =~ /mingw/i
      "gcc"
    elsif host_os =~ /darwin/i
      "clang"
    elsif host_os =~ /linux/i
      "gcc"
    else
      abort("Unknown 'host_os' #{host_os}!")
    end
  end

  private_class_method :toolchain

  def self.is_known_toolchain?(toolchain)
    case toolchain.downcase
    when "gcc"
      true
    when "clang"
      true
    when "msvc"
      true
    else
      false
    end
  end

  private_class_method :is_known_toolchain?

  def self.is_supported_toolchain?(toolchain)
    host_os = RbConfig::CONFIG['host_os'].downcase
    case toolchain.downcase
    when "gcc"
      if host_os =~ /mingw/i
        true
      else
        true
      end
    when "clang"
      if host_os =~ /mingw/i
        false
      else
        true
      end
    when "msvc"
      if host_os =~ /mingw/i
        true
      else
        false
      end
    else
      false
    end
  end

  private_class_method :is_supported_toolchain?

  def self.platform
    host_os = RbConfig::CONFIG['host_os'].downcase
    if host_os =~ /mingw/i
      "windows-mingw"
    elsif host_os =~ /darwin/i
      "macosx"
    elsif host_os =~ /linux/i
      "linux"
    else
      abort("Unknown 'host_os' #{host_os}!")
    end
  end

  private_class_method :platform

  def self.is_known_platform?(platform)
    case platform.downcase
    when "windows-mingw"
      true
    when "macosx"
      true
    when "linux"
      true
    else
      false
    end
  end

  private_class_method :is_known_platform?

  def self.is_supported_platform?(platform)
    case platform.downcase
    when "windows-mingw"
      true
    when "macosx"
      false
    when "linux"
      false
    else
      false
    end
  end

  private_class_method :is_supported_platform?

  def self.paranoid?(switches_and_options)
    switches_and_options.paranoid
  end

  private_class_method :paranoid?

  def self.debug?(switches_and_options)
    (switches_and_options.config == 'debug')
  end

  private_class_method :debug?

  def self.development?(switches_and_options)
    debug?(switches_and_options) || (switches_and_options.config == 'development')
  end

  private_class_method :development?

  def self.release?(switches_and_options)
    development?(switches_and_options) || (switches_and_options.config == 'release')
  end

  private_class_method :release?

  def self.yes_or_no(value)
    if value
      "yes"
    else
      "no"
    end
  end

  private_class_method :yes_or_no

  def self.parse(args)
    switches_and_options = OpenStruct.new

    switches_and_options.paranoid     = (switch 'paranoid')
    switches_and_options.config       = (option 'config')
    switches_and_options.architecture = (option 'architecture')
    switches_and_options.toolchain    = (option 'toolchain')
    switches_and_options.platform     = (option 'platform')
    switches_and_options.windows_sdk  = (option 'windows_sdk')
    switches_and_options.msvc         = (option 'msvc')

    parser = OptionParser.new do |opts|
      opts.banner =  "Usage: ./configure [switches and options]"
      opts.separator ""
      opts.separator "Switches & Options:"

      opts.on("--paranoid", "Defines BT_PARANOID, which enables paranoid checks.") do
        switches_and_options.paranoid = true
      end

      opts.on("--config=CONFIG", "Selects debug, development, or release configurations.") do |config|
        switches_and_options.config = config.downcase
      end

      opts.on("--architecture=ARCHITECTURE", "Compile for the specified architecture.") do |architecture|
        switches_and_options.architecture = architecture
      end

      opts.on("--toolchain=COMPILER", "Uses the specified toolchain.") do |toolchain|
        switches_and_options.toolchain = toolchain
      end

      opts.on("--platform=PLATFORM", "Builds for the specified platform.") do |platform|
        switches_and_options.platform = if platform.downcase == 'windows'
                                          'windows-mingw'
                                        else
                                          platform
                                        end
      end

      opts.on("--windows-sdk=PATH", "Specifies the Windows SDK to use when using Microsoft Visual Studio.") do |sdk|
        switches_and_options.windows_sdk = sdk
      end

      opts.on("--msvc=PATH", "Specifies which verison of Microsoft Visual Studio to use.") do |msvc|
        switches_and_options.msvc = msvc
      end

      opts.on("--h", "--help") do
        puts parser
        exit
      end
    end

    parser.parse!(args.dup)
    return switches_and_options
  end

  def self.sane?(switches_and_options)
    if not switches_and_options.config
      puts "No configuration specified, defaulting to 'debug'..."
      switches_and_options.config = 'debug'
    else
      if not (is_known_configuration? switches_and_options.config)
        puts "Unknown configuration '#{switches_and_options.config}'!"
        return false
      end
    end

    if switches_and_options.architecture
      if is_known_architecture? switches_and_options.architecture
        if not (is_supported_architecture? switches_and_options.architecture)
          puts "Unsupported architecture '#{switches_and_options.architecture}'!"
          return false
        end
      else
        puts "Unknown architecture '#{switches_and_options.architecture}'!"
        return false
      end
    else
      switches_and_options.architecture = architecture
      puts "No architecture specified, defaulting to '#{switches_and_options.architecture}'..."
      if not (is_supported_architecture? switches_and_options.architecture)
        puts "Unsupported architecture '#{switches_and_options.architecture}'!"
        return false
      end
    end

    if switches_and_options.toolchain
      if is_known_toolchain? switches_and_options.toolchain
        if not(is_supported_toolchain? switches_and_options.toolchain)
          puts "Unsupported toolchain '#{switches_and_options.toolchain}'!"
          return false
        end
      else
        puts "Unknown toolchain '#{switches_and_options.toolchain}'!"
        return false
      end
    else
      switches_and_options.toolchain = toolchain
      puts "No toolchain specified, defaulting to '#{switches_and_options.toolchain}'..."
      if not (is_supported_toolchain? switches_and_options.toolchain)
        puts "Unsupported toolchain '#{switches_and_options.toolchain}'!"
        return false
      end
    end

    if switches_and_options.platform
      if is_known_platform? switches_and_options.platform
        if not(is_supported_platform? switches_and_options.platform)
          puts "Unsupported platform '#{switches_and_options.platform}'!"
          return false
        end
      else
        puts "Unknown platform '#{switches_and_options.platform}'!"
        return false
      end
    else
      switches_and_options.platform = platform
      puts "No platform specified, defaulting to '#{switches_and_options.platform}'..."
      if not (is_supported_platform? switches_and_options.platform)
        puts "Unsupported platform '#{switches_and_options.platform}'!"
        return false
      end
    end

    if switches_and_options.toolchain.downcase == 'msvc'
      if not switches_and_options.windows_sdk
        puts "Windows SDK not specified!"
        return false
      elsif not switches_and_options.msvc
        puts "Microsoft Visual Studio path not specified!"
        return false
      end
    end

    true
  end

  def self.generate(switches_and_options, path)
    File.open(path, 'wb') do |f|
      f.write "# Do not modify this file! Instead, modify ./configure!\n"
      f.write "# This file was generated by ./configure #{ARGV.join(' ')}\n"
      f.write "\n"

      f.write "PARANOID     := #{yes_or_no(paranoid?(switches_and_options))}\n"
      f.write "DEBUG        := #{yes_or_no(debug?(switches_and_options))}\n"
      f.write "DEVELOPMENT  := #{yes_or_no(development?(switches_and_options))}\n"
      f.write "RELEASE      := #{yes_or_no(release?(switches_and_options))}\n"
      f.write "\n"

      f.write "ARCHITECTURE := #{switches_and_options.architecture}\n"
      f.write "TOOLCHAIN    := #{switches_and_options.toolchain}\n"
      f.write "PLATFORM     := #{switches_and_options.platform}\n"
      f.write "\n"

      if switches_and_options.toolchain.downcase == 'msvc'
        f.write "WINDOWS_SDK  := #{switches_and_options.windows_sdk}\n"
        f.write "MSVC_PATH    := #{switches_and_options.msvc}\n"
        f.write "\n"
      end

      return true
    end

    false
  end
end

switches_and_options = SwitchesAndOptions.parse(ARGV)

if not (SwitchesAndOptions.sane? switches_and_options)
  puts "Configuration failed."
  exit false
end

if not (SwitchesAndOptions.generate(switches_and_options, "config.mk"))
  puts "Generation failed."
  File.delete("config.mk")
  exit false
end

puts "Configuration succesful!"
